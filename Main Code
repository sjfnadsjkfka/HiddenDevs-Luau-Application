--[[  
    CONTROLS:  
    - Left Mouse Button: Place Portal 1 (Blue)  
    - Right Mouse Button: Place Portal 2 (Orange)  

    FEATURES:  
    - Raycast-based placement for precision.  
    - Surface normal alignment for correct orientation.  
    - ViewportFrame-based rendering to see through portals.  
    - Smooth teleportation with momentum preservation.  
    - Visual effects and tweens for a polished feel.  
    - Cooldown system to prevent spam.  
    - Highly configurable settings.  
    - Optimized for performance.  
]]  

--// SERVICES //--  
local UserInputService = game:GetService("UserInputService") -- Get the UserInputService for detecting input  
local Players = game:GetService("Players") -- Get the Players service to access the local player  
local RunService = game:GetService("RunService") -- Get RunService for render updates  
local TweenService = game:GetService("TweenService") -- Get TweenService to animate portal opening  
local Workspace = game:GetService("Workspace") -- Get Workspace to place portal parts  
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Get ReplicatedStorage (not used here but commonly needed)  

--// CONFIGURATION //--  
local CONFIG = {  
	MAX_PLACEMENT_DISTANCE = 200,      -- Maximum distance from player to place a portal  
	PORTAL_COOLDOWN = 0.5,             -- Time between placing portals to prevent spamming  
	TELEPORT_COOLDOWN = 1,             -- Time between player teleports  
	PORTAL_SIZE = Vector3.new(6, 8, 0.2), -- Size of the portal frame  
	PORTAL_COLOR_1 = Color3.fromRGB(0, 170, 255),  -- Color for portal 1 (blue)  
	PORTAL_COLOR_2 = Color3.fromRGB(255, 170, 0),  -- Color for portal 2 (orange)  
	PORTAL_OPEN_TIME = 0.3,            -- Animation duration for portal opening  
}  

--// PLAYER AND MOUSE VARIABLES //--  
local player = Players.LocalPlayer -- Reference to the local player  
local character = player.Character or player.CharacterAdded:Wait() -- Get the player's character, wait if not loaded  
local humanoid = character:WaitForChild("Humanoid") -- Get the Humanoid object for movement detection  
local rootPart = character:WaitForChild("HumanoidRootPart") -- Get the HumanoidRootPart for position reference  
local mouse = player:GetMouse() -- Get the player's mouse  

--// PORTAL STATE //--  
local portal1 = nil -- Store data for portal 1  
local portal2 = nil -- Store data for portal 2  
local portal1Camera = nil -- Camera for portal 1 (see-through effect)  
local portal2Camera = nil -- Camera for portal 2 (see-through effect)  
local lastPlacementTime = 0 -- Timestamp of last portal placement  
local lastTeleportTime = 0 -- Timestamp of last teleport  
local connections = {} -- Store event connections for cleanup  

--// PRELOADS & TEMPLATES //--  
local portalTemplate = Instance.new("Part") -- Base template for portal frame  
portalTemplate.Name = "PortalFrame" -- Name the part  
portalTemplate.Anchored = true -- Keep it stationary in the world  
portalTemplate.CanCollide = false -- Disable collisions  
portalTemplate.Material = Enum.Material.Neon -- Make it visually glowing  
portalTemplate.TopSurface = Enum.SurfaceType.Smooth -- Smooth top surface  
portalTemplate.BottomSurface = Enum.SurfaceType.Smooth -- Smooth bottom surface  
portalTemplate.Size = CONFIG.PORTAL_SIZE -- Set size from configuration  

local portalVisualTemplate = Instance.new("Part") -- Visual part inside portal frame  
portalVisualTemplate.Name = "PortalVisual" -- Name the visual part  
portalVisualTemplate.Anchored = true -- Anchored in world  
portalVisualTemplate.CanCollide = false -- Non-collidable  
portalVisualTemplate.Transparency = 0.2 -- Slightly transparent  
portalVisualTemplate.Material = Enum.Material.ForceField -- Visual material  
portalVisualTemplate.Color = Color3.fromRGB(200, 200, 200) -- Light gray color  
portalVisualTemplate.Size = Vector3.new(CONFIG.PORTAL_SIZE.X * 0.8, CONFIG.PORTAL_SIZE.Y * 0.8, 0.1) -- Slightly smaller than frame  

local portalTriggerTemplate = Instance.new("Part") -- Invisible trigger part for teleport detection  
portalTriggerTemplate.Name = "PortalTrigger" -- Name the trigger  
portalTriggerTemplate.Anchored = true -- Anchored in world  
portalTriggerTemplate.CanCollide = false -- Non-collidable  
portalTriggerTemplate.Transparency = 1 -- Completely invisible  
portalTriggerTemplate.Size = portalVisualTemplate.Size + Vector3.new(0, 0, 2) -- Slightly larger to detect touches  

--// FUNCTIONS //--  

-- Cleans up an existing portal and its associated objects  
local function cleanupPortal(portalData)  
	if not portalData then return end -- Exit if no portal exists  
	if portalData.model and portalData.model:IsA("Model") and portalData.model.PrimaryPart then  
		local tween = TweenService:Create(portalData.model.PrimaryPart, TweenInfo.new(CONFIG.PORTAL_OPEN_TIME), {Size = Vector3.new(0,0,0)}) -- Shrink animation  
		tween:Play() -- Play shrinking animation  
		tween.Completed:Wait() -- Wait until animation is done  
		portalData.model:Destroy() -- Destroy portal model  
	elseif portalData.model and portalData.model:IsA("Model") then  
		portalData.model:Destroy() -- Destroy portal if no primary part  
	end  
	if portalData.camera then portalData.camera:Destroy() end -- Destroy portal camera if exists  
	if portalData.connection then portalData.connection:Disconnect() end -- Disconnect trigger event  
end  

-- Creates the visual model for a portal  
local function createPortalModel(portalColor)  
	local model = Instance.new("Model") -- Create model container  
	model.Name = "Portal" -- Name the model  

	local frame = portalTemplate:Clone() -- Clone portal frame  
	frame.Color = portalColor -- Apply color  
	frame.Parent = model -- Parent to model  
	model.PrimaryPart = frame -- Set primary part  

	local visual = portalVisualTemplate:Clone() -- Clone visual part  
	visual.Parent = frame -- Parent to frame  
	local weld = Instance.new("WeldConstraint") -- Create weld to attach visual  
	weld.Part0 = frame -- Connect frame  
	weld.Part1 = visual -- Connect visual  
	weld.Parent = frame -- Parent weld  

	local trigger = portalTriggerTemplate:Clone() -- Clone trigger part  
	trigger.Parent = frame -- Parent to frame  
	local triggerWeld = Instance.new("WeldConstraint") -- Weld trigger  
	triggerWeld.Part0 = frame -- Frame side  
	triggerWeld.Part1 = trigger -- Trigger side  
	triggerWeld.Parent = frame -- Parent weld  

	local surfaceGui = Instance.new("SurfaceGui") -- Create GUI for viewport  
	surfaceGui.Face = Enum.NormalId.Front -- Attach to front face  
	surfaceGui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud -- Scale per stud  
	surfaceGui.PixelsPerStud = 150 -- Pixels per stud  
	surfaceGui.Parent = visual -- Parent to visual  

	local viewportFrame = Instance.new("ViewportFrame") -- Frame for seeing through portals  
	viewportFrame.Size = UDim2.fromScale(1, 1) -- Fill surface  
	viewportFrame.BackgroundColor3 = Color3.new(0,0,0) -- Black background  
	viewportFrame.BorderColor3 = portalColor -- Border matches portal color  
	viewportFrame.BorderSizePixel = 5 -- Border thickness  
	viewportFrame.Parent = surfaceGui -- Parent to SurfaceGui  

	return model, viewportFrame -- Return portal model and viewport  
end  

-- Updates the ViewportFrame cameras every frame for the "see-through" effect  
local function updatePortalViews()  
	if not (portal1 and portal2 and portal1.model and portal2.model and portal1.model.PrimaryPart and portal2.model.PrimaryPart) then return end -- Check portals exist  

	local p1CFrame = portal1.model.PrimaryPart.CFrame -- Portal 1 CFrame  
	local p2CFrame = portal2.model.PrimaryPart.CFrame -- Portal 2 CFrame  
	local playerHead = player.Character and player.Character:FindFirstChild("Head") -- Get player head  
	if not playerHead then return end -- Exit if no head  

	-- Update portal 2's view (seen from portal 1)  
	if portal1.camera then  
		local relativeCFrame = p1CFrame:ToObjectSpace(playerHead.CFrame) -- Relative to portal 1  
		local transformedCFrame = p2CFrame * CFrame.Angles(0, math.pi, 0) * relativeCFrame -- Transform to portal 2  
		portal1.camera.CFrame = transformedCFrame -- Apply to camera  
	end  

	-- Update portal 1's view (seen from portal 2)  
	if portal2.camera then  
		local relativeCFrame = p2CFrame:ToObjectSpace(playerHead.CFrame) -- Relative to portal 2  
		local transformedCFrame = p1CFrame * CFrame.Angles(0, math.pi, 0) * relativeCFrame -- Transform to portal 1  
		portal2.camera.CFrame = transformedCFrame -- Apply to camera  
	end  
end  

-- Links the two portals together so they can render each other  
local function linkPortals()  
	if not (portal1 and portal2) then return end -- Exit if portals don't exist  

	if not portal1.camera then -- Create camera for portal 1 if missing  
		portal1.camera = Instance.new("Camera") -- Create camera  
		portal1.camera.Parent = portal1.viewport -- Parent to viewport  
		portal1.viewport.CurrentCamera = portal1.camera -- Set current camera  
	end  

	if not portal2.camera then -- Create camera for portal 2 if missing  
		portal2.camera = Instance.new("Camera") -- Create camera  
		portal2.camera.Parent = portal2.viewport -- Parent to viewport  
		portal2.viewport.CurrentCamera = portal2.camera -- Set current camera  
	end  

	if connections.renderStep then connections.renderStep:Disconnect() end -- Disconnect previous render step  
	connections.renderStep = RunService.RenderStepped:Connect(updatePortalViews) -- Update portals every frame  
end  

-- Handles the actual teleportation logic  
local function onPortalTouched(touchedPart, sourcePortal, destinationPortal)  
	if not (sourcePortal and destinationPortal and sourcePortal.model and destinationPortal.model) then return end -- Exit if portals missing  
	if tick() - lastTeleportTime < CONFIG.TELEPORT_COOLDOWN then return end -- Respect teleport cooldown  

	local partParent = touchedPart.Parent -- Get parent of touched part  
	if not (partParent and partParent == character) then return end -- Only teleport the player  

	lastTeleportTime = tick() -- Update teleport timestamp  

	local root = partParent:FindFirstChild("HumanoidRootPart") -- Get root part  
	if not root then return end -- Exit if missing  

	local sourceCFrame = sourcePortal.model.PrimaryPart.CFrame -- Source portal CFrame  
	local destCFrame = destinationPortal.model.PrimaryPart.CFrame -- Destination portal CFrame  

	local offset = sourceCFrame:inverse() * root.CFrame -- Player's relative position to source portal  
	local relativeVel = sourceCFrame:VectorToObjectSpace(root.AssemblyLinearVelocity) -- Player's relative velocity  

	local exitOffset = CFrame.Angles(0, math.pi, 0) * offset -- Rotate 180 degrees for exit  
	local exitRelativeVel = CFrame.Angles(0, math.pi, 0):VectorToWorldSpace(relativeVel) -- Rotate velocity  

	local exitCFrame_raw = destCFrame * exitOffset -- Raw exit CFrame  

	local pos = exitCFrame_raw.Position -- Exit position  
	local look = exitCFrame_raw.LookVector -- Exit look vector  
	local up = Vector3.new(0, 1, 0) -- Default up vector  

	if math.abs(look.Y) > 0.95 then -- If looking mostly up/down  
		up = exitCFrame_raw.RightVector -- Adjust up vector to prevent roll  
	end  

	local exitCFrame_upright = CFrame.lookAt(pos, pos + look, up) -- Reconstruct upright CFrame  

	root.CFrame = exitCFrame_upright + destCFrame.LookVector * 2 -- Move player slightly forward  

	root.AssemblyLinearVelocity = destCFrame:VectorToWorldSpace(exitRelativeVel) -- Preserve velocity  
end  

-- Places a portal at the mouse's target position  
local function placePortal(portalNumber)  
	if tick() - lastPlacementTime < CONFIG.PORTAL_COOLDOWN then return end -- Respect placement cooldown  

	local raycastParams = RaycastParams.new() -- Create raycast params  
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist -- Exclude certain objects  
	local filterList = {character} -- Start blacklist with player  
	if portal1 and portal1.model then table.insert(filterList, portal1.model) end -- Add portal1  
	if portal2 and portal2.model then table.insert(filterList, portal2.model) end -- Add portal2  
	raycastParams.FilterDescendantsInstances = filterList -- Apply filter  

	local rayOrigin = rootPart.Position -- Ray starts at player's root  
	local rayDirection = (mouse.Hit.Position - rayOrigin).Unit -- Direction to mouse  

	local raycastResult = Workspace:Raycast(rayOrigin, rayDirection * CONFIG.MAX_PLACEMENT_DISTANCE, raycastParams) -- Perform raycast  

	if raycastResult and raycastResult.Instance and raycastResult.Instance.CanCollide then -- If hit a valid surface  
		lastPlacementTime = tick() -- Update placement timestamp  

		local position = raycastResult.Position -- Hit position  
		local normal = raycastResult.Normal -- Hit surface normal  

		local pos = position + normal * 0.1 -- Offset slightly from wall  
		local lookAtPos = pos - normal -- Look at opposite direction  
		local up = Vector3.new(0, 1, 0) -- Default up vector  

		if math.abs(normal.Y) > 0.95 then -- Adjust up vector if floor/ceiling  
			local playerLook = rootPart.CFrame.LookVector -- Get player horizontal look  
			up = Vector3.new(playerLook.X, 0, playerLook.Z).Unit -- Horizontal up  
		end  

		local portalCFrame = CFrame.lookAt(pos, lookAtPos, up) -- Final portal CFrame  

		if portalNumber == 1 then -- If placing portal 1  
			cleanupPortal(portal1) -- Remove existing portal 1  
			local model, viewport = createPortalModel(CONFIG.PORTAL_COLOR_1) -- Create portal 1  
			model.Parent = Workspace -- Parent to workspace  
			model:SetPrimaryPartCFrame(portalCFrame) -- Set position  

			portal1 = { -- Store portal 1 data  
				model = model,  
				viewport = viewport,  
				camera = nil,  
				connection = nil  
			}  
			portal1.connection = model.PrimaryPart.PortalTrigger.Touched:Connect(function(part) -- Connect teleport trigger  
				onPortalTouched(part, portal1, portal2)  
			end)  

		elseif portalNumber == 2 then -- If placing portal 2  
			cleanupPortal(portal2) -- Remove existing portal 2  
			local model, viewport = createPortalModel(CONFIG.PORTAL_COLOR_2) -- Create portal 2  
			model.Parent = Workspace -- Parent to workspace  
			model:SetPrimaryPartCFrame(portalCFrame) -- Set position  

			portal2 = { -- Store portal 2 data  
				model = model,  
				viewport = viewport,  
				camera = nil,  
				connection = nil  
			}  
			portal2.connection = model.PrimaryPart.PortalTrigger.Touched:Connect(function(part) -- Connect teleport trigger  
				onPortalTouched(part, portal2, portal1)  
			end)  
		end  

		local frame = (portalNumber == 1 and portal1.model.PrimaryPart) or (portalNumber == 2 and portal2.model.PrimaryPart) -- Get portal frame  
		frame.Size = Vector3.new() -- Shrink to zero for animation  
		TweenService:Create(frame, TweenInfo.new(CONFIG.PORTAL_OPEN_TIME, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = CONFIG.PORTAL_SIZE}):Play() -- Animate opening  

		if portal1 and portal2 then -- If both portals exist  
			linkPortals() -- Link for see-through effect  
		end  
	end  
end  

-- Handle user input for placing portals  
local function onInputBegan(input, gameProcessed)  
	if gameProcessed then return end -- Ignore if GUI used input  

	if input.UserInputType == Enum.UserInputType.MouseButton1 then -- Left click  
		placePortal(1) -- Place portal 1  
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then -- Right click  
		placePortal(2) -- Place portal 2  
	end  
end  

--// INITIALIZATION //--  
UserInputService.InputBegan:Connect(onInputBegan) -- Connect input listener  

player.CharacterRemoving:Connect(function() -- Cleanup when player leaves  
	cleanupPortal(portal1) -- Cleanup portal 1  
	cleanupPortal(portal2) -- Cleanup portal 2  
	portal1 = nil -- Clear reference  
	portal2 = nil -- Clear reference  
	for _, conn in pairs(connections) do -- Disconnect any remaining connections  
		if conn then conn:Disconnect() end  
	end  
	connections = {} -- Clear connection table  
end)  
